#### 分布式理论

##### 分布式系统概念

```
一般认为：一个分布式系统是一些独立的计算机集合，但是对这个系统的用户来说，系统就像一台计算机一样。这个定义有两方面的含义：第一，从硬件角度来说，每台计算机都是自主的；第二，从软件角度来说，用户将整个系统看做是一台计算机。这两者都是必需的，缺一不可。
```

##### 分布式系统的主要特征

- 分布性：系统中的多台计算机之间没有主，从之分，即没有控制整个系统的主机，也没有受控的从机。
- 透明性：系统资源被所有计算机共享。每台计算机的用户不仅可以使用本机的资源，还可以使用本分布式系统中其他计算机的资源（包括CPU、文件、打印机等）
- 同一性：系统中的若干台计算机可以互相协作来完成一个共同的任务，或者说一个程序可以分布在几台计算机上并行地运行。
- 通信性：系统中任意两台计算机都可以通过通信来交换信息

##### 分布式系统面临的问题

- 通信异常

  网络本身的不可靠性，会导致消息丢失和消息延迟

- 网络分区

  网络之间出现网络不连通，但子网的内部网络是正常的，从而导致整个的网络环境被切分为几个独立的区域，分布式系统就会出现局部小集群，这对分布式一致性提出非常大的挑战

- 节点故障

  服务器节点出现宕机或“僵死”

- 三态

  成功、失败、超时

##### 分布式一致性

```
指的是数据在多个副本中的值是一致的
```

###### 一致性分类

- 严格一致性：对于数据项x的任何读操作都返回最近一次写操作的结果

  严格一致性，是在系统不发生任何故障，且所有节点之间的通信无需任何时间这种理想的状态下才能达到。这个时候整个系统其实就等价于一台机器了，在现实中，是不可能达到的

  实际上，越强的一致性往往会造成越弱的处理性能，以及越差的可扩展性

- 强一致性：当分布式系统中更新操作完成之后，任何多个进程或线程，访问系统都会获得最新的值

  一般来说，强一致性主要包括下面两类

  顺序一致性：要求所有线程所见的整个程序的总体执行顺序是一样的

  线性一致性：假设操作具有一个全局有效时钟的时间戳，要求时间戳在前的进程先执行。线性化是根据一系列同步时钟确定序列顺序的

- 弱一致性：指系统并不保证后续进程或线程的访问都能返回最新的值。但在某个时间级别（秒级）之后，可以让数据达到一致性状态

- 最终一致性：是弱一性的特定形式。系统保证在没有后续更新的情况下，系统最终返回上一次更新操作的值。经过一段时间后能访问到更新后的数据，则是最终一致性

###### 一致性协议2PC

两阶段提交协议，是将整个事务流程分为两个阶段：准备阶段、提交阶段

![image-20200615204157527](C:\Users\x1850\AppData\Roaming\Typora\typora-user-images\image-20200615204157527.png)

两阶段过程

1. 准备阶段：事务管理器给每个参与者发送prepaer消息，每个数据库参与者在本地执行事务，并写本地的undo/redo日志，此时事务没有提交。（undo日志是记录修改前的数据，用于数据库回滚，redo日志记录修改后的数据，用于提交事务后写入数据文件）

2. 提交阶段：如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚消息，否则，发送提交消息。参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。（必须在最后阶段释放锁资源）

   ![image-20200615204834842](C:\Users\x1850\AppData\Roaming\Typora\typora-user-images\image-20200615204834842.png)

```
prepare阶段：
	事务询问：协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应
	执行事务、写本地undo/redo日志
	各参与者向协调者反馈事务询问的响应
	
commit阶段：
	发送提交请求：协调者向所有参与者发出commit请求
	事务提交：参与者收到commit请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间所占有的资源
	反馈事务提交结果：参与者完成事务提交后，向协调者发送ACK信息
	完成事务：协调者接收所有参与者反馈的ACk信息后，完成事务
	
	
2PC优缺点：
	优点：原理简单、实现方便
	缺点：同步阻塞、单点问题、数据不一致、过于保守
	同步阻塞：各个参与者在等待其他参与者响应的过程中，无法进行其他操作
	单点问题：协调者一旦出问题，那么整个流程将无法运转
	数据不一致：只有部分参与者收到commit请求，导致数据不一致
	过于保守：没有较为完善的容错机制，任意一个节点失败都会导致整个事务的失败
```

###### 一致性协议3PC

3PC是2PC的改进版，将2PC的“提交事务请求”过程一分为二，共形成了由canCommit、preCommit和doCommit三个阶段组成的事务处理协议

![image-20200615211841587](C:\Users\x1850\AppData\Roaming\Typora\typora-user-images\image-20200615211841587.png)

```
canCommit阶段：
	事务询问：协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应
	各参与者向协调者发送询问响应

preCommit阶段：
	执行事务预提交或中断事务。假如所有参与者反馈的都是yes，那么就会执行事务预提交。否，中断事务
	执行事务预提交分为3个步骤
		1、发送预提交请求
			协调者向所有参与者发出preCommit请求，并进入prepared阶段
		2、事务预提交
			参与者收到preCommit请求后，会执行事务操作，并记录undo/redo
		3、各参与者向协调者反馈事务执行的结果
			成功执行事务操作，返回ACk
			
	若任一参与者返回no或者等待超时后，则中断事务
	中断事务分为2个步骤
    	1、发送中断abort请求
    	2、中断事务
	
doCommit阶段：
	执行事务提交
	1、发送提交请求
	2、事务提交
	3、反馈事务提交结果
	4、完成事务
	
	中断事务
	1、发送中断请求
	2、事务回滚
	3、反馈事务回滚结果
	4、中断事务
	
	注意：一旦进入阶段三，可能会出现2中故障
		1、协调者出现问题
		2、协调者和参与者之间网络故障
		如果出现任一情况，最终都会导致参与者无法收到doCommit请求，对于这种情况，参与者都会在等待超时之后，继续进行事务提交
	
```

```
2PC VS 3PC
1、2PC中只有协调者拥有超时机制，即在一定时间内没有收到参与者的消息则默认失败。3PC中协调者和参与者都设置了超时机制，主要是避免了参与者在长时间无法与协调者通讯（参与者会在超时后，自动进行本地commit从而释放资源。这种机制也从侧面降低了整个事务的阻塞时间和范围）
2、3PC相对于2PC而言，多设置了一个缓冲阶段保证了在最后提交阶段之前各参与节点的状态是一致的
3、preCommit是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的
问题：3PC协议并没有完全解决数据不一致问题
```

###### 一致性算法Paxos

```
Paxos算法是Lamport提出的一种基于消息传递的分布式一致性算法，解决了分布式系统一致性问题
Paxos相关概念
	提案（Proposal）:proposal信息包括提案编号和提议的值
Paxos算法中，由如下角色
	Client：客户端
		客户端向分布式系统发出请求并等待响应。
	Proposer：提案发起者
		提案者提倡客户请求，视图说服Acceptor对此达成一致，并在发生冲突时充当协调者以推动协议向前发展
	Acceptor：决策者，可以批准提案
		Acceptor可以接收提案，如果某个提案被选定，那么该提案里的value就被选定了
	Learners：最终决策的学习者
		学习者充当该协议的复制因素
	
```

![image-20200615222751171](C:\Users\x1850\AppData\Roaming\Typora\typora-user-images\image-20200615222751171.png)

问题描述：

假设有一组可以提出提案的进程集合，那么对于一个一致性算法需要保证以下几点：

- 在这些被提出的提案中，只有一个会被选定
- 如果没有提案被提出，就不应该有被选定的提案
- 当一个提案被选定后，那么所有进程都应该能学习到这个被选定的value

Paxos算法描述

![image-20200615223645492](C:\Users\x1850\AppData\Roaming\Typora\typora-user-images\image-20200615223645492.png)

​	阶段一：

- Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求
- 如果一个Acceptor收到一个编号为N的Prepare请求，且N大于该Acceptor已经响应过的Prepare请求的编号，那么它就会将它已经接受过的编号最大的提案作为响应反馈给Proposer，同时Acceptor承诺不再接受任何编号小于N的提案

阶段二：

- 如果Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针对[N,V]提案的Accept请求给半数以上的Acceptor。（注意：V就是收到的响应中编号最大的提案的Value,如果响应中不包含任何提案，那么V就由Proposer自己决定）	
- 如果Acceptor收到一个编号为N的提案的accept请求，只要Acceptor没有对编号大于N的prepares做出响应，它就该接受该提案

Learner学习被选定的value

![image-20200615225136873](C:\Users\x1850\AppData\Roaming\Typora\typora-user-images\image-20200615225136873.png)

###### 如何保证Paxos算法的活性

活性：最终一定会发生的事情（最终一定要选定value）

问题：假设存在这样一种极端情况，有两个Proposer依次提出了一系列编号递增的提案，导致最终陷入死循环，没有value被选定

解决：通过选取主Proposer，并规定只有主Proposer才能提出议案。这样一来只要主proposer和过半的acceptor能够正常进行网络通信，只要Proposer提出一个编号更高的提案，该提案终将会被批准，整套Paxos算法就能保持活性

###### 一致性算法Raft

```
一种为了管理复制日志的算一致性算法
```

###### Raft算法分为3个模块

- 领导人选举
- 日志复制
- 安全性

###### Raft中的角色

- 领导者：处理与客户端的交互，日志复制等动作
- 候选者：选举过程中自荐的服务器，一旦选举成功则成为领导者
- 跟随着：类似选民，完全被动的角色，这类服务器等待被通知投票

Raft使用心跳机制来触发选举。当服务器启动时，初始状态都是follower。每一个服务器都有一个定时器，超时时间为election timeout(一般为150-300ms)，如果超时，它就开始一次选举

###### 节点异常

节点异常大致分为四种类型：

- leader不可用
- follower不可用
- 多个candidate或多个leader
- 新节点加入集群

###### 日志复制

leader选出后，就开始接收客户端的请求。leader把请求作为日志条目(log entries)加入到它的日志中，然后向其他服务器发起AppendEntries RPC复制日志条目。当这条日志被复制到大多数服务器上，leader将这条日志应用到它的状态机并向客户端返回执行结果

![image-20200616083220556](C:\Users\x1850\AppData\Roaming\Typora\typora-user-images\image-20200616083220556.png)

###### 分布式理论：CAP定理

```
CAP理论表明，一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个基本需求，最多只能同时满足其中的2个
```

| 特性       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 一致性     | 所有节点的数据是一致的                                       |
| 可用性     | 系统一直可用                                                 |
| 分区容错性 | 系统在遇到一些节点或者网络分区故障的时候，仍然能够提供满足一致性和可用性的服务 |

###### 分布式理论：BASE理论

```
BASE理论包含三个部分：
Basically Available基本可用：指分布式系统在出现不可预知故障的时候，允许损失部分可用性
Soft state软状态：允许系统在多个节点中的数据在数据同步过程中存在延迟
Eventually consistent最终一致性：经过一段时间后，数据最终达到一致性状态

BASE是对CAP中一致性和可用性进行权衡的结果。其理论的核心思想是：即使无法做到强一致性，但每个应用都可以很具自身的业务特点采用适当的方式来使系统达到最终一致性
```

#### 分布式系统设计策略

###### 心跳检测

```
以固定的频率向其他节点汇报当前节点状态的方式
```

###### 高可用设计

```
经过设计减少系统不能提供服务的时间。系统高可用性的常用设计模式有三种：主备（Master-Slave）、互备（Active-Active）和集群（cluster）
```

- 主备模式

  当主机宕机时，备机接管主机的一切工作。当主机恢复正常后，按使用者的设定以自动（热备）或手动（冷备）方式切换到主机上运行

- 互备模式

  互备模式指两台主机同时运行且相互监测

- 集群模式

  指多个节点同时运行，可通过主控节点分担服务请求

###### 容错性

```
容错顾名思义就是系统对错误的包容能力。容错处理保障了分布式系统的高可用
```

###### 负载均衡

```
把网络请求分配到集群中不同的服务器节点上
```

负载均衡有硬件解决方案，也有软件解决方案。硬件解决方案有著名的F5，软件有LVS、HAProxy、Nginx等

#### 分布式架构网络通信

```
网络通信就是一段二进制流从一台计算机传输到另外一台计算机，基于传输协议和网络IO来实现。传输协议：TCP、UDP；网络IO：BIO、NIO、AIO
```
######　RPC

```
remote procedure call远程过程调用，借助RPC可以做到像调用本地服务一样调用远程服务。
```

一个完整的RPC架构里面包含了四个核心的组件，分别是Client、Client Stub、Server以及Server Stub，这个Stub可以理解为存根

- Client客户端：服务的调用方
- Client Stub客户端存根：存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络发送给服务方
- Server服务端：服务提供者
- Server Stub服务端存根：接收客户端发送过来的消息，将消息解包，并调用本地的方法

######　RMI

```
remote method invocation远程方法调用，是java原生支持的远程调用，采用JRMP（Java remote messageing protocal）作为通信协议。RMI主要用于不同虚拟机之间的通信
```

RMI架构

- 客户端

  Stub存根/桩：远程对象再客户端上的代理

  remote reference layer远程引用层：解析并执行远程引用协议

  transport传输层：发送调用，传递远程方法参数，接收远程方法执行结果

- 服务端

  skeleton骨架：读取客户端传递的方法参数，调用方法

  remote reference layer远程引用层：处理远程引用，向骨架发送远程方法调用

  transport传输层：监听客户端的入站连接，接收并转发，调用远程引用层

- 注册表：以URL形式注册远程对象，并向客户端返回远程对象的引用

###### IO

- 同步 VS 异步

  同步、异步是针对应用程序和内核的交互而言的

  同步：指用户进程触发IO操作时等待或者轮询的方式查看IO操作是否就绪

  异步：异步调用，调用者不会立刻得到结果，而是被调用者通过回调函数来进行通知

- 阻塞 VS 非阻塞

  阻塞、非阻塞是针对进程访问数据的时候，根据IO操作的就绪状态来采取不同的方式

- BIO VS NIO VS AIO

  BIO同步阻塞IO：一个连接一个线程

  NIO同步非阻塞IO：一个请求一个通道，客户端发送的请求都会被注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理
  
  AIO异步非阻塞IO：当有流可以读时，操作系统会将流读入read方法的缓冲区；写操作，OS会将write的结果通知应用程序

######　Netty 

```
异步的，基于事件驱动的网络编程框架
```

Netty优点

- 对各种传输协议提供同意的API
- 高度可定制的线程模型
- 更好的吞吐量，更低的延迟等待
- 更少的资源消耗
- 最小化不必要的内存拷贝

